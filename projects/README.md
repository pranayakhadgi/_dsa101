# Project Penumbra: Development Roadmap Explained (Reality-Based)

This roadmap exists for one reason, to stop you from lying to yourself about what you can build and when. There is no Machine Learning, no fantasy scope creep, no vague “improve AI later” nonsense. Each week has exactly one DSA focus and exactly one visible game outcome. If at the end of a week you cannot play something new, the week failed.

The timeline starts at Week 2 because Week 1 already happened conceptually. You learned what the game is, you accepted that everything is a grid, and you stopped romanticizing complexity. From here on, everything is execution.

Week 2, Dec 22 to Dec 28, is about building the world itself. The DSA focus is graphs and grids. This is where the game stops being a static square and becomes a place. You begin the week with a blank screen again, because you should be able to recreate the foundation without copying. Early in the week you add player movement on a grid. Midweek you hard code a single room just to confirm collision and boundaries work. The real work happens when you write the dungeon generation logic. You use DFS or BFS to carve paths through a grid so that every open tile is reachable. By the end of the week, the game window opens and you can walk through a randomly generated maze that changes every run. It will be ugly. It should be ugly. Colored squares are enough. If you waste time on visuals here, you are dodging the hard part. The deliverable is Prototype v0.1, a playable maze, nothing more. If someone else presses WASD and gets lost in your dungeon, you succeeded.

Week 3, Dec 29 to Jan 4, adds meaning to movement. The DSA focus shifts to hash tables and search. A maze alone is a tech demo, not a game. This week is about state. You introduce items and persistence. Early in the week you define what an item even is in code. Then you build the inventory as a HashMap, because lookup speed matters and this is the cleanest real example of why hash tables exist. Midweek you place a key in the dungeon. Then you add a door that checks the inventory before changing state. Late in the week you add the exit condition and a minimal UI, even if that UI is just text saying “Key acquired” or “Door unlocked”. By Sunday, Prototype v0.2 exists. You can pick up a key, open a door, and reach an exit. This is the first moment the project feels intentional instead of technical.

Week 4, Jan 5 to Jan 11, introduces threat. The DSA focus is trees and pathfinding, but practically this means BFS on your grid. You add an enemy, just one. No variety, no polish. The enemy’s entire brain is “find the shortest path to the player”. Early in the week you create the Enemy class. Then you implement BFS so the enemy can search the dungeon graph you already built. When it works, the enemy moves one tile at a time toward the player. After that, you add collision damage and a basic health variable. Finally, you add a game over state. Prototype v0.3 is the result. Now the game has tension. You can lose. It is still simple, but it finally feels alive. If pathfinding is slow or clunky, good. That exposes real constraints you can reason about later.

Week 5, Jan 12 to Jan 18, is where you stop adding systems and start connecting them. The DSA focus is general algorithms and polish, not because polish is fancy, but because integration is hard. You add level progression, meaning the game resets into a new dungeon when you win. You design one special room that acts as a boss or final challenge, even if the boss is just a tougher enemy with more health. You add clear win and lose screens. You clean up logic that became messy in earlier weeks. You may use simple algorithms like sorting to organize inventory or string manipulation to clean up HUD text. At the end of this week, Prototype v0.4 exists. This is an alpha. It has a beginning, a middle, and an end. You can die. You can win. That alone puts you ahead of most unfinished student projects.

Week 6 and beyond is optional but important. This is where you earn confidence instead of chasing it. You review what you built, identify weak points, and add exactly one fun feature of your choice. Not five. One. Spells, traps, shops, smarter enemies, better level generation, anything that makes the game more interesting without breaking it. This phase ends with Version 1.0, not because it is perfect, but because it is stable, complete, and demonstrably yours.

The daily structure stays the same throughout all weeks. In the morning, you study the DSA concept of the week and implement a small isolated example, not related to the game. In the afternoon, you apply that exact concept to Project Penumbra. At the end of the day, you run the game and commit something tangible to GitHub. If nothing changed visually or interactively, you did not finish the day.

The key mindset is the prototype mindset. v0.1 is not a game, it is proof your world generation works. v0.2 is not a game, it is proof interaction works. v0.3 is the first version that feels like a game. This staged approach is not about lowering standards, it is about controlling complexity. You only ever fight one new problem at a time. If something feels too hard, simplify it and move forward. Improvement comes after completion, not before.

This roadmap is realistic. If you fail, it will not be because the plan was flawed, it will be because you skipped fundamentals, chased polish too early, or stopped shipping playable builds.
