# Project Penumbra: How It Actually Works

Let’s stop pretending this is mysterious or fancy. This is not about lore, vibes, or some big game dev fantasy. This is about what actually shows up on the screen and the code that makes it happen. From nothing to something, step by step.

We start on Day 1 with a completely blank project. No assets, no systems, no clever abstractions. The only goal is to make a window appear and draw one single static square inside it. That square is Ali. That is the entire game at this point. If you cannot do this, nothing else matters.

To draw that square, we use a 2D array. Think of it like graph paper. Each cell is a coordinate. grid[5][10] might be empty space, grid[5][11] might be a wall, and grid[6][10] is Ali. We literally tell the computer what exists at each coordinate. When the window opens, you see one square on a flat background. That’s it. The DSA concept here is arrays. Just a grid. Simple, boring, foundational. Everything else is built on top of this.

Once the square exists, it becomes a game the moment we add a loop. A game is just a loop that runs around 60 times per second. Each loop does three things. First, input. Did the player press W, A, S, or D. Second, update. If they did, change Ali’s position in the grid, for example from [5][10] to [5][9]. Third, render. Clear the screen and redraw everything at the new positions. That’s the whole idea. The entire project is just making this loop smarter and making what we draw more interesting.

Right now the grid is boring. One hard coded room. So the next step is letting the computer build the world. We write a function called generateDungeon(). It randomly places rooms on a large grid and then connects them by carving paths through walls. To guarantee everything connects, we use Depth First Search. DFS works like walking forward as far as you can, hitting a dead end, backtracking, and trying another path. Breadcrumb logic. This guarantees that every room is reachable and the maze is solvable. Suddenly, every time the program runs, you get a different dungeon. The grid is no longer just an array. It becomes a graph. Rooms are nodes. Corridors are edges. You are literally walking through a data structure.

Walking through a maze alone is boring, so we add interaction. The simplest possible interaction is a key and a door. The door has a locked boolean and a keyId. The key has an id. When Ali walks over a key, we run a collision check. If true, we add the key to Ali’s inventory. When Ali walks up to a door, we check if the door is locked and whether Ali’s inventory contains the correct key. If it does, the door unlocks. The inventory itself is stored in a HashMap. inventory["blue_key"] = true literally means “I have the blue key.” Checking for a key is instant. No looping, no searching. This is a clean, real use of hash maps.

A quiet maze is still not a game, so we add pressure. We introduce a guard. The guard has one rule: if it can reach the player, it moves toward them. To do this, it uses Breadth First Search. Every second or so, the guard takes its own grid position as a starting point and runs BFS through the maze. BFS floods the maze level by level, guaranteeing the shortest path. When it finds Ali’s position, it knows exactly which direction to move. This is not smart AI. It’s just BFS, queues, and loops, running in real time. It feels intense, but it’s mechanically simple.

Finally, we define win and lose conditions. Lose condition is straightforward. If the guard’s grid position equals Ali’s grid position, Ali takes damage. When health reaches zero, the screen shows GAME OVER. Win condition is also simple. Once the door is unlocked, an exit tile appears. When Ali reaches that tile, the screen shows LEVEL CLEARED. Then we generate a new dungeon, maybe bigger or harder, reset positions, and continue.

That’s the entire plan. A grid using arrays. A maze built with DFS. Items tracked with a hash map. An enemy that searches using BFS. Simple rules that compare grid positions. Every complex sounding game dev concept boils down to changing values in data structures and redrawing the screen. We are not trying to build a masterpiece. We are building a working, playable prototype that proves we understand DSA in a real, interactive way. We start with one square. We end with a chase through a generated maze. Step by step. Line by line.
